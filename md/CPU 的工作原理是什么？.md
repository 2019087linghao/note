> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.zhihu.com](https://www.zhihu.com/question/40571490/answer/1856781108)

想了解 CPU 的工作原理莫过于**从头开始用最基础的元素打造一个简单 CPU。**

**接下来我会从最简单的晶体管开始一步步讲解 CPU 是如何构造出来的，明白了这个过程理解 CPU 的工作原理不在话下，在此之后我会从最基础的二进制机器指令一步步讲解高级语言的基本原理，通读本文后你将彻底明白 CPU 与高级语言的工作原理。**

以下内容出自我的两篇文章《[你管这破玩意叫 CPU？](https://zhuanlan.zhihu.com/p/367927405)》《[你管这破玩意叫编程语言？](https://zhuanlan.zhihu.com/p/359941312)》。

每次回家开灯时你有没有想过，用你按的简单开关实际上能打造出复杂的 CPU 来，只不过需要的数量会比较多，也就**几十亿**个吧。

**伟大的发明**
---------

过去 200 年人类最重要的发明是什么？蒸汽机？电灯？火箭？这些可能都不是，最重要的也许是这个小东西：

这个小东西就叫**晶体管**，你可能会问，晶体管有什么用呢？

实际上晶体管的功能简单到不能再简单，给一端通上电，那么电流可以从另外两端通过，否则不能通过，其本质就是一个开关。

**AND、OR、NOT**
--------------

*   两个开关只有同时打开电流才会通过，灯才会亮
*   两个开关中只要有一个打开电流就能通过，灯就会亮
*   当开关关闭时电流通过灯会亮，打开开关灯反而电流不能通过灯会灭

![](https://pic1.zhimg.com/v2-6601c7a6580b8f650c6e2e49afa6356e_r.jpg?source=1940ef5c)

**道生一、一生二、二生三、三生万物**
--------------------

最神奇的是，你随手搭建的三种电路竟然有一种很 amazing 的特性，那就是：任何一个逻辑函数最终都可以通过 AND、OR 以及 NOT 表达出来，这就是所谓的逻辑完备性，就是这么神奇。

也就是说**给定足够的 AND、OR 以及 NOT 门，就可以实现任何一个逻辑函数，除此之外我们不需要任何其它类型的逻辑门电路，**这时我们认为 {AND、OR、NOT} 就是逻辑完备的。

这一结论的得出吹响了计算机革命的号角，这个结论告诉我们计算机最终可以通过简单的 {AND、OR、NOT} 门构造出来，就好比基因。

![](https://pic2.zhimg.com/v2-f9129382758ab4358f3bf1719ed7d9e1_r.jpg?source=1940ef5c)

老子有云：**道生一、一生二、二生三、三生万物，实乃异曲同工之妙**。虽然，我们可以用 AND、OR、NOT 来实现所有的逻辑运算，但我们真的需要把所有的逻辑运算都用 AND、OR、NOT 门实现出来吗？显然不是，而且这也不太可行。

**计算能力是怎么来的**
-------------

现在能生成万物的基础元素与或非门出现了，接下来我们着手设计 CPU 最重要的能力：计算，以加法为例。由于 CPU 只认知 0 和 1，也就是二进制，那么二进制的加法有哪些组合呢：

*   0 + 0，结果为 0，进位为 0
*   0 + 1，结果为 1，进位为 0
*   1 + 0，结果为 1，进位为 0
*   1 + 1，结果为 0，进位为 1，二进制嘛！

注意进位一列，只有当两路输入的值都是 1 时，进位才是 1 ，看一下你设计的三种组合电路，这就是与门啊，有没有！再看下结果一列，当两路输入的值不同时结果为 1，输入结果相同时结果为 0，这就是异或啊，有没有！

我们说过与或非门是逻辑完备可以生万物，异或逻辑当然不在话下，用一个与门和一个异或门就可以实现二进制加法：

![](https://pic2.zhimg.com/v2-2a3c69207d7e4d20a44862e75c9fdf43_r.jpg?source=1940ef5c)

上述电路就是一个简单的加法器，就问你神奇不神奇，加法可以用与或非门实现，其它的也一样能实现，逻辑完备嘛。

除了加法，我们也可以根据需要将不同的算数运算设计出来，负责计算的电路有一个统称，这就是所谓的 arithmetic/logic unit，ALU，CPU 中专门负责运算的模块，本质上和上面的简单电路没什么区别，就是更加复杂而已。

现在，通过与或非门的组合我们获得了计算能力，计算能力就是这么来的。但，只有计算能力是不够的，电路需要能**记得住**信息。

### **神奇的记忆能力**

到目前为止，你设计的组合电路比如加法器天生是没有办法存储信息的，它们只是简单的根据输入得出输出，但输入输出总的有个地方能够保存起来，这就是需要电路能保存信息。

电路怎么能保存信息呢？你不知道该怎么设计，这个问题解决不了你寝食难安，吃饭时在思考、走路时在思考，蹲坑时在思考，直到有一天你在梦中遇一位英国物理学家，他给了你这样一个简单但极其神奇的电路：

![](https://pic1.zhimg.com/v2-44ea3219990b694b441ec22c51a6a08a_r.jpg?source=1940ef5c)

这是两个 NAND 门的组合，不要紧张，NAND 也是有你设计的与或非门组合而成的，所谓 NAND 门就是与非门，先与然后取非，比如给定输入 1 和 0，那么与运算后为 0，非运算后为 1，这就是与非门，这些不重要。

比较独特的是该电路的组合方式，**一个 NAND 门的输出是两一个 NAND 门的输入**，该电路的组合方式会自带一种很有趣的特性，**只要给 S 和 R 段输入 1，那么这个电路只会有两种状态**:

*   要么 a 端为 1，此时 B=0、A=1、b=0；
*   要么 a 端为 0，此时 B=1、A=0、b=1;

不会再有其他可能了，**我们把 a 端的值作为电路的输出**。

此后，你把 S 端置为 0 的话 (R 保持为 1)，那么电路的输出也就是 a 端永远为 1，这时就可以说我们把 1 存到电路中了；而如果你把 R 段置为 0 的话 (S 保持为 1)，那么此时电路的输出也就是 a 端永远为 0，此时我们可以说把 0 存到电路中了。

就问你神奇不神奇，**电路竟然具备存储信息的能力了**。现在为保存信息你需要同时设置 S 端和 R 端，但你的输入是有一个 (存储一个 bit 位嘛)，为此你对电路进行了简单的改造：

![](https://pica.zhimg.com/v2-266a2ac1972f0a2590e8cfda557af614_r.jpg?source=1940ef5c)

这样，当 D 为 0 时，整个电路保存的就是 0，否则就是 1。

**寄存器与内存的诞生**
-------------

现在你的电路能存储一个比特位了，想存储多个比特位还不简单，复制粘贴就可以了：

![](https://pica.zhimg.com/v2-a6b85e03c21d8fde999fa84d8daf48e6_r.jpg?source=1940ef5c)

我们管这个组合电路就叫**寄存器**，你没有看错，我们常说的寄存器就是这个东西。

你不满足，还要继续搭建更加复杂的电路以存储更多信息，同时提供寻址功能，就这样**内存**也诞生了。

寄存器及内存都离不开上一节那个简单电路，只要通电，这个电路中就保存信息，但是断电后很显然保存的信息就丢掉了，**现在你应该明白为什么内存在断电后就不能保存数据了吧**。

### **硬件还是软件？**

现在我们的电路可以计算数据、也可以存储信息，但现在还有一个问题，那就是尽管我们可以用 AND、OR、NOT 表达出所有的逻辑函数，但我们真的有必要把所有的逻辑运算都用与或非门实现出来吗？这显然是不现实的。

这就好比厨师，你没有听说只专做一道菜的厨师然后酒店要把各个菜系厨师雇全才能做出一桌菜来吧！

中国菜系博大精深，千差万别，但制作每道菜品的方式大同小异，其中包括刀工、颠勺技术等，这些是基本功，制作每道菜品都要经过这些步骤，变化的也无非就是食材、火候、调料等，这些放到菜谱中即可，这样给厨师一个菜谱他就能制作出任意的菜来，在这里厨师就好比硬件，菜谱就好比软件。

![](https://pica.zhimg.com/v2-9b88df74bdc51e910fb25cc08020904f_r.jpg?source=1940ef5c)

同样的道理，**我们没有必要为所有的计算逻辑实现出对应的硬件**，硬件只需要提供最基本的功能，最终所有的计算逻辑都通过这些最基本的功能用软件表达出来就好，这就是所谓的软件一词的来源，**硬件不可变，但软件可变**，**不变的是硬件但提供不同的软件就能让硬件实现全新的功能**，**无比天才的思想**，人类真的是太聪明了。

同样一台计算机硬件，安装上 word 你就能编辑文档，安装上微信你就能在公号中读到码农的荒岛求生、安装上游戏你就能玩王者农药，硬件还是那套硬件，提供不同的软件就是实现不同的功能，**每次打开电脑使用各种 App 时没有在内心高呼一声牛逼你都对不起计算机这么伟大的发明创造**，这就是为什么计算机被称为**通用**计算设备的原因，这一思想是计算机科学祖师爷图灵提出的。

说到牛逼的通用设备，在这样也推荐一份牛逼的**算法刷题资料，除了本文讲到的底层技术，，想进 BAT、TMD、快手这样的一线大厂算法绝不可忽视，认认真真过上一遍这份资料，这些大厂算法面试一关大部分题目都不在话下**：

扯远了，接下来我们看下硬件是怎么提供所谓的基本功能的。

**硬件的基本功**
----------

让我们来思考一个问题，CPU 怎么能知道自己要去对两个数进行加法计算，以及哪两个数进行加法计算呢？

很显然，你得告诉 CPU，该怎么告诉呢？还记得上一节中给厨师的菜谱吗？没错，CPU 也需要一张菜谱告诉自己该接下来该干啥，在这里菜谱就是机器指令，指令通过我们上述实现的组合电路来执行。

接下来我们面临另一个问题，那就是这样的指令应该会很多吧，废话，还是以加法指令为例，你可以让 CPU 计算 1+1，也可以计算 1+2 等等，实际上单单加法指令就可以有无数种组合，显然 CPU 不可能去实现所有的指令。

实际上 CPU 只需要提供**加法操作**，你提供**操作数**就可以了，CPU 说：“我可以打人”，你告诉 CPU 该打谁、CPU 说：“我可以唱歌”，你告诉 CPU 唱什么，CPU 说我可以做饭，你告诉 CPU 该做什么饭，CPU 说：“我可以炒股”，你告诉 CPU 快滚一边去吧韭菜。因此我们可以看到 CPU 只提供**机制**或者说功能 (打人、唱歌、炒菜，加法、减法、跳转)，我们提供**策略** (打谁、歌名、菜名，操作数，跳转地址)。

CPU 表达机制就通过指令集来实现的。

**指令集**
-------

指令集告诉我们 CPU 可以执行什么指令，每种指令需要提供什么样的操作数。不同类型的 CPU 会有不同的指令集。指令集中的指令其实都非常简单，画风大体上是这样的：

*   从内存中读一个数，地址是 abc
*   对两个数加和
*   检查一个数是不是大于 6
*   把这数存储到内存，地址是 abc
*   等等

看上去很像碎碎念有没有，这就是机器指令，我们用高级语言编写的程序，比如对一个数组进行排序，**最终都会等价转换为上面的碎碎念指令，然后 CPU 一条一条的去执行，很神奇有没有**。接下来我们看一条可能的机器指令：

![](https://pica.zhimg.com/v2-98468a1839411c05e8de94d6866be93a_r.jpg?source=1940ef5c)

这条指令占据 16 比特，其中前四个比特告诉 CPU 这是加法指令，这意味着该 CPU 的指令集中可以包含 2^4 也就是 16 个机器指令，这四个比特位告诉 CPU 该做什么，剩下的 bit 告诉 CPU 该怎么做，也就是把寄存器 R6 和寄存器 R2 中的值相加然后写到寄存器 R6 中。

可以看到，机器指令是非常繁琐的，现代程序员都使用高级语言来编写程序，关于高级程序语言以及机器指令的话题请参见《[你管这破玩意叫编程语言？](https://zhuanlan.zhihu.com/p/359941312)》。

[码农的荒岛求生：你管这破玩意叫编程语言？](https://zhuanlan.zhihu.com/p/359941312)

**指挥家：让我们演奏一曲**
---------------

现在我们的电路有了计算功能、存储功能，还可以通过指令告诉该电路执行什么操作，还有一个问题没有解决。

我们的电路有很多部分，用来计算的、用来存储的，以最简单的加法为例，假设我们要计算 1+1，这两个数分别来自寄存器 R1 和 R2，要知道寄存器中可以保存任意值，**我们怎么能确保加法器开始工作时 R1 和 R2 中在这一时刻保存的都是 1 而不是其它数**？

即，我们靠什么来协调或者说靠什么来同步电路各个部分让它们协同工作呢？就像一场成功的交响乐演离不开指挥家一样，我们的计算组合电路也需要这样一个指挥家。

![](https://pic1.zhimg.com/v2-b93e98f4c910b58ad4bca663f0530036_r.jpg?source=1940ef5c)

负责指挥角色的就是时钟信号。

时钟信号就像指挥家手里拿的指挥棒，**指挥棒挥动一下整个乐队会整齐划一的有个相应动作**，同样的，时钟信号每一次电压改变，整个电路中的各个寄存器 (也就是整个电路的状态) 会更新一下，这样我们就能确保整个电路协同工作不会这里提到的问题。

现在你应该知道 CPU 的主频是什么意思了吧，主频是说一秒钟指挥棒挥动了多少次，显然主频越高 CPU 在一秒内完成的操作也就越多。

**大功告成**
--------

现在我们有了可以完成各种计算的 ALU、可以存储信息的寄存器以及控制它们协同工作的时钟信号，这些统称 **Central Processing Unit**，简称就是 **CPU**。

接下来我们看一下 CPU 与高级语言。

**创世纪：聪明的笨蛋**
-------------

CPU 相当原始，就像单细胞生物一样，只能把数据从一个地方搬到另一个地方、简单的加一下，没有任何高难度动作，这些操作虽然看上去很简单很笨，但 CPU 有一个无与伦比的优势，那就是一个字：快，这是人类比不了了的，**CPU 出现后人类开始拥有第二个大脑**。就是这样原始的一个物种开始支配起另一个叫做程序员的物种。

**干活的是大爷**
----------

一般来说两个不同的物种要想交流，比如人和鸟，就会有两种方式：要不就是鸟说人话，让人听懂；要不就是人说鸟语，让鸟听懂；就看谁厉害了。最开始 CPU 胜出，程序员开始说鸟语并认真感受 CPU 的支配地位，好让 CPU 大爷可以工作，感受一下最开始的程序员是怎么说鸟语的：

![](https://pic3.zhimg.com/v2-5217ee8f03de90c5b20af177d0232196_r.jpg?source=1940ef5c)

程序员按照 CPU 的旨意直接用 0 和 1 编写指令，你没有看错，这破玩意就是代码了，就是这么原生态，然后放到打孔纸带上输入给 CPU，CPU 开始工作，这时的程序可真的是看得见摸得着，就是有点浪费纸。

这时程序员必须站在 CPU 的角度来写代码，画风是这样的：

乍一看你知道这是什么意思吗？你不知道，心想：“这是什么破玩意？”，但 CPU 知道，心想 “这就简直就是世界上最美的语言”。

**天降大任**
--------

终于有一天程序员受够了说鸟语，好歹也是灵长类，叽叽喳喳说鸟语太没面子，你被委以重任：让程序员说人话。你没有苦其心志劳其筋骨，而是仔细研究了一下 CPU，发现 CPU 执行的指令集来来回回就那么几个指令，比如加法指令、跳转指令等等，因此你把机器指令和对应的具体操作做了一个简单的映射，**把机器指令映射到人类能看懂的单词**，这样上面的 01 串就变成了：

```
sub $8, %rsp
 mov $.LC0, %edi
 call puts
 mov $0, %eax
```

这样，程序员不必生硬的记住 1011.....，而是记住人类可以认识的 ADD SUB MUL DIV 等这样的单词即可。

![](https://picx.zhimg.com/v2-3be1443d5d2a6b0e3bbca7d09f55b712_r.jpg?source=1940ef5c)

汇编语言就这样诞生了，**编程语言中首次出现了人类可以认识的东西**。

这时程序员终于不用再 “叽叽喳喳。。”，而是升级为“阿巴阿巴。。”，虽然人类认知“阿巴阿巴” 这几个字，但这和人类的语言**在形式上**差别还是有点大。

**细节 VS 抽象**
------------

尽管汇编语言已经有人类可以认识的单词，但汇编语言和机器语言一样都属于低级语言。所谓低级语言是说你需要**关心所有细节**。关心什么细节呢？我们说过，CPU 是非常原始的东西，只知道把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方。因此，如果你想用低级语言来编程的话，**你需要使用多个 “把数据从一个地方搬到另一个地方，简单的操作一下再从一个地方搬到另一地方” 这样的简单指令来实现诸如排序这样复杂的问题**。有的同学可能对此感触不深，这就好比，本来你想表达 “去给我端杯水过来”：

![](https://picx.zhimg.com/v2-369de9a4dc02c8a8c611c531094037f5_r.jpg?source=1940ef5c)

如果你用汇编这种低级语言就得这样实现：

![](https://pic2.zhimg.com/v2-ff96abb43db63fc71cfbeac8eb78a495_r.jpg?source=1940ef5c)

我想你已经 Get 到了。

**弥补差异**
--------

CPU 实在太简单了，简单到不能了理解任何稍微抽象一点诸如 “给我端杯水” 这样的东西，但人类天生习惯抽象化的表达，人类和机器的差距有办法来弥补吗？换句话说就是**有没有一种办法可以自动把人类抽象的表达转为 CPU 可以理解的具体实现**，这显然可以极大增强程序员的生产力，现在，这个问题需要你来解决。

![](https://pic1.zhimg.com/v2-a59ecc9b5438141368226e2aba8ab01a_r.jpg?source=1940ef5c)

**套路，都是套路**
-----------

思来想去你都不知道该怎么把人类的抽象自动转为 CPU 能理解的具体实现，就在要放弃的时候你又看了一眼 CPU 可以理解的一堆细节：

![](https://pic1.zhimg.com/v2-e58ef6353d84e82c122a8a1a4e507ffa_r.jpg?source=1940ef5c)

**电光火石之间灵光乍现，你发现了满满的套路，或者说模式**。大部分情况下 CPU 执行的指令平铺直叙的，就像这样：

![](https://pica.zhimg.com/v2-89198737ef963928a5cf2e4f6f88b2c0_r.jpg?source=1940ef5c)

这些都是告诉 CPU 完成某个特定动作，你给这些平铺直叙的指令起了个名字，姑且就叫陈述句吧，statement。

除此之外，你还发现了这样的套路，那就是需要根据某种特定状态决定走哪段指令，这个套路在人看来就是 “如果。。。就。。。否则。。就。。。”：

```
if ***  
   blablabla
 else *** 
   blablabla
```

在某些情况下还需要不断重复一些指令，这个套路看起来就是原地打转：

```
while ***  
   blablabla
```

最后就是这里有很多看起来差不多的指令，就像这里：

![](https://pic1.zhimg.com/v2-7e8490ab8ae3397d57649be7b609f04c_r.jpg?source=1940ef5c)

这些指令是重复的，只是个别细节有所差异，把这些差异提取出来，剩下的指令打包到一起，用一个代号来指定这些指令就好了，这要有个名字，就叫函数吧：

```
func abc: 
   blablabla
```

现在你发现了所有套路：

```
// 条件转移
 if ***  
      blablabla
   else ***
      blablabla
// 循环
  while ***
      blablabla
// 函数
 func abc:
      blablabla
```

**这些相比汇编语言已经有了质的飞跃，因为这已经和人类的语言非常接近了**。接下来你发现自己面临两个问题：

1.  这里的 blablabla 该是什么呢？
2.  该怎样把上面的人类可以认识的字符串转换为 CPU 可以认识的机器指令

**盗梦空间**
--------

你想起来了，上文说过大部分代码都是平铺直叙的陈述句，statement，这里的 blablabla 仅仅就是一堆陈述句吗？显然不是，blablabla 可以是陈述句，当然也可以是条件转移 if else，也可以是循环 while，也可以是调用函数，这样才合理。虽然这样合理，很快你就发现了另一个严重的问题：blabalbla 中可以包含 if else 等语句，**而 if else 等语句中又可以包含 blablabla，blablabla 中反过来又双可能会包含 if else 等语句，if else 等语句又双叒有可能会包含 blablabla，blablabla 又双叒叕可能会包含 if else 等语句。。。**

![](https://picx.zhimg.com/v2-7e89acc83a07255f57552d81642e87a1_r.jpg?source=1940ef5c)

就像盗梦空间一样，一层梦中还有一层梦，梦中之梦，梦中之梦中之梦。。。一层嵌套一层，子子孙孙无穷匮也。。。

![](https://picx.zhimg.com/v2-9572ff61bad922d836ece9274e539028_r.jpg?source=1940ef5c)

此时你已经明显感觉脑细胞不够用了，这也太复杂了吧，绝望开始吞噬你，上帝以及老天爷啊，谁来救救我！

此时你的高中老师过来拍了拍你的肩膀，递给了你一本高中数学课本，你恼羞成怒，给我这破玩意干什么，我现在想的问题这么高深，岂是一本破高中数学能解决的了的，抓过来一把扔在了地上。此时一阵妖风吹过，教材停留在了这样一页，上面有这样一个数列表达：

```
f(x) = f(x-1) + f(x-2)
```

这个递归公式在表达什么呢？f(x) 的值依赖 f(x-1)，f(x-1) 的值又依赖 f(x-2)，f(x-2) 的值又依赖。。。

![](https://pic1.zhimg.com/v2-b1194769a2df25fb7232aa6031a60349_r.jpg?source=1940ef5c)

一层嵌套一层，梦中之梦，if 中嵌套 statement，statement 又可以嵌套 if。。。

等一下，这不就是递归嘛，**上面看似无穷无尽的嵌套也可以用递归表达啊**！你的数学老师仰天大笑，too young too simple，留下羞愧的你佛手而去，看似高科技的东西竟然用高中数学就解决了，一时震惊的目瞪狗带不知所措无地自容。有了递归这个概念加持，聪明的智商又开始占领高地了。

**递归：代码的本质**
------------

不就是嵌套嘛，一层套一层嘛，递归天生就是来表达这玩意的 (**提示：这里的表达并不完备，真实的编程语言不会这么简单，这里仅仅用作示例**)：

```
if : if bool statement else statements
 for: while bool statements
 statement: if | for | statement
```

上面一层嵌套一层的盗梦空间原来可以这么简洁的几句表达出来啊，你给这几句表达起了高端的名字，**语法**。**数学，就是可以让一切都变得这么优雅**。世界上所有的代码，不管有多么复杂最终都可以归结到语法上，原因也很简单，所有的代码都是按照语法的形式写出来的嘛。至此，你发明了真正的人类可以认识的编程语言。之前提到的第一个问题解决了，但仅仅有语言还是不够的。

**让计算机理解递归**
------------

现在还差一个问题，怎样才能把这语言最终转化为 CPU 可以认识的机器指令呢？人类可以按照语法写出代码，这些代码其实就是一串字符，怎么让计算机也能认识用递归语法表达的一串字符呢？这是一项事关人类命运的事情，你不禁感到责任重大，但这最后一步又看似困难重重，你不禁仰天长叹，计算机可太难了。此时你的初中老师过来拍了拍你的肩膀，递给了你一本初中植物学课本，你恼羞成怒，给我这破玩意干什么，我现在想的问题这么高深，岂是一本破初中教科书能解决的了的，抓过来一把扔在了地上。此时又一阵妖风挂过，书被翻到了介绍树的一章，你望着这一页不禁发起呆来：

![](https://pic3.zhimg.com/50/v2-0d54a5bef637b3a88c0cb09930611288_720w.jpg?source=1940ef5c)

树干下面是树枝，树枝下是树叶，树枝下也可以是树枝，树枝下还可以是树枝、吃葡萄不吐葡萄皮，不吃葡萄倒吐葡萄皮，哎？这句不对，回到上面这句，树干生树枝，树枝还可以生树枝，一层套一层、梦中之梦、子子孙孙无穷匮、高中数学老师，等一下，这也是递归啊！！！**我们可以把根据递归语法写出来的的代码用树来表示啊**！

![](https://pica.zhimg.com/v2-47e1c6361bd3dde7f31f4a8f9156689f_r.jpg?source=1940ef5c)

你的初中老师仰天大笑，图样图森破，看似高科技的东西竟然靠初中知识就解决了。

**优秀的翻译官**
----------

计算机处理编程语言时可以按照递归定义把代码用树的形式组织起来，由于这棵树是按照语法生成的，姑且就叫**语法树**吧。现在代码被表示成了树的形式，你仔细观察后发现，其实叶子节点的表达是非常简单的，可以很简单的翻译成对应的机器指令，只要叶子节点翻译成了机器指令，**你就可以把此结果应用到叶子节点的父节点，父节点又可以把翻译结果引用到父节点的父节点，一层层向上传递，最终整颗树都可以翻译成具体的机器指令**。

![](https://pic3.zhimg.com/v2-dbd25eea2b3d3267e6397c0c3809b9c6_r.jpg?source=1940ef5c)

完成这个工作的程序也要有个名字，根据 “弄不懂原则”(该原则的解释见下文 :)

[看完这篇还不懂高并发中的线程与线程池你来打我 (内含 20 张图)](http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&mid=2247484768&idx=1&sn=049db350af9e5eea5cf3523ceb83f447&chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&scene=21#wechat_redirect)

，你给这个类似翻译的程序起了个不怎么响亮的名字，编译器，compiler。

**现在你还觉得二叉树之类的数据结构没啥用吗**？对了，**说到二叉树，**在这样也推荐一份牛逼的**算法刷题资料，想进 BAT、TMD、快手这样的一线大厂算法绝不可忽视，认认真真过上一遍这份资料，这些大厂算法面试一关大部分题目都不在话下**：

[Github 疯传！阿里 P8 大佬写的 Leetcode 刷题笔记，秒杀 80% 的算法题！](https://mp.weixin.qq.com/s/A-HPH3Tkl8KOvZgdRArvIg)

至此，你完成了一项了不起的发明创造，程序员可以用人类认识的东西来写代码，你编写的一个叫做编译器的程序负责将其翻译成 CPU 可以认识的机器指令。后人根据你的思想构建出了 C/C++、以及后续的 Java、Python，这些语言现在还有一帮人在用呢。

**总结**
------

本文我们从最基本的晶体管一路讲解到 CPU 的工作原理，再从最低级的二进制机器指令到高级语言，相信如果你能读到这里定能有所收获。

最后，有同学问有没有书单，我也仔细回想自己认真读过的计算机数据，在这里也给出自认为很经典的几本，书单这东西**贵精不贵多**，我在这里精心挑选了 10 本 ，**不要贪心，如果你真能把这里推荐的 10 本书读通，可以说你已经能超越 90% 的程序员了。**

[程序员必看经典书单](https://mp.weixin.qq.com/s/4T-ZLWasVDQVY99gCFfqUA)

最后的最后，**有很多知乎朋友问有没有 pdf 版本，我也整理出来了，[绘图](https://www.zhihu.com/search?q=%E7%BB%98%E5%9B%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A420039025%7D)非常精美，这里还汇总了部分知乎问题，总计 14 万字，我为其专门设计了封面，并将其命名为《计算机底层的秘密》，现在免费分享给大家。**

![](https://pica.zhimg.com/v2-d4bd1b37bb52f033213cc7260a64f58b_r.jpg?source=1940ef5c)![](https://pic1.zhimg.com/v2-8c23b3670d5815439806d79c65a18ad9_r.jpg?source=1940ef5c)

**可以使用这个下载链接**：[点击下载《计算机底层的秘密》 PDF](https://wwo.lanzouy.com/iRzGHy347cf)

如果你觉得本文有所帮助，给点个赞呗！

@码农的荒岛求生

作者：**码农的荒岛求生**

**Github:** [https://github.com/xfenglu/everycodershouldknow](https://github.com/xfenglu/everycodershouldknow)

原文：**[你管这破玩意叫 CPU？](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;mid=2247485736&amp;idx=1&amp;sn=a70558b5200e840ef251e19a2eef099b&amp;chksm=cfe995a8f89e1cbe8fab1240515f35ec90fb520d122ec60761b71a8664ae3af390689be370aa&token=2096033094&lang=zh_CN#rd)**

**[你管这破玩意叫编程语言？](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&amp;mid=2247485731&amp;idx=1&amp;sn=9f8dbed55312c6c10527496cf8e7a982&amp;chksm=cfe995a3f89e1cb5608f5c69dc518227b2d737a2ed97f58d14b3d80a8a23b2d238e4780332ff&token=2096033094&lang=zh_CN#rd)**

推荐：

[码农的荒岛求生：CPU 空闲时在干嘛？](https://zhuanlan.zhihu.com/p/356447262)